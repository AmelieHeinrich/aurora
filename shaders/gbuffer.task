#version 450

#extension GL_NV_mesh_shader : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_KHR_shader_subgroup_ballot : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

const float pi_half = 1.57079;

struct Meshlet
{
	vec4 sphere;
	uint vertices[64];   
    uint indices_packed[124*3/4];   
    uint8_t vertex_count;
	uint8_t triangle_count;
};	

layout (binding = 1, set = 4) readonly buffer Meshlets 
{
	Meshlet meshlets[];
};

layout (binding = 0, set = 0) uniform Camera {
	mat4 projection;
	mat4 view;
	vec3 pos;
	float pad;
	vec4 frustrum_planes[6];
} camera;

layout (push_constant) uniform Model {
	mat4 transform;
} model;

out taskNV block
{
	uint meshletIndices[32];
};

bool InsideFrustum(vec4 sphere)
{
	return (dot(camera.frustrum_planes[0].xyz, sphere.xyz) - camera.frustrum_planes[0].w > -sphere.w)
	    && (dot(camera.frustrum_planes[1].xyz, sphere.xyz) - camera.frustrum_planes[1].w > -sphere.w)
		&& (dot(camera.frustrum_planes[2].xyz, sphere.xyz) - camera.frustrum_planes[2].w > -sphere.w)
		&& (dot(camera.frustrum_planes[3].xyz, sphere.xyz) - camera.frustrum_planes[3].w > -sphere.w)
		&& (dot(camera.frustrum_planes[4].xyz, sphere.xyz) - camera.frustrum_planes[4].w > -sphere.w)
		&& (dot(camera.frustrum_planes[5].xyz, sphere.xyz) - camera.frustrum_planes[5].w > -sphere.w);
}

shared uint meshletCount;

void main()
{
	uint ti = gl_LocalInvocationID.x;
	uint mgi = gl_WorkGroupID.x;
	uint mi = mgi * 32 + ti;

	bool accept = InsideFrustum(meshlets[mi].sphere);
	uvec4 ballot = subgroupBallot(accept);

	uint index = subgroupBallotExclusiveBitCount(ballot);

	if (accept)
		meshletIndices[index] = mi;

	uint count = subgroupBallotBitCount(ballot);

	if (ti == 0)
		gl_TaskCountNV = count;
}